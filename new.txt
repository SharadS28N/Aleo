import speech_recognition as sr
import google.generativeai as genai
import webbrowser
import pyttsx3
import time
import requests
from datetime import datetime
from langdetect import detect
import yt_dlp
import vlc
from config import gemini_api_key, weather_api_key

# Global variables
stop_flag = False  # Ensure this is defined at the top
current_player = None
music_playing = False

# Configure Google Gemini API
genai.configure(api_key=gemini_api_key)
model = genai.GenerativeModel(model_name="gemini-1.5-pro-latest")
convo = model.start_chat(history=[])

# Initialize pyttsx3
engine = pyttsx3.init()
voices = engine.getProperty('voices')

# Function to select female voice (if available)
def set_voice(lang="en"):
    global voices
    for voice in voices:
        print(f"Available voice: {voice.name}")  # Debug print to list available voices
        if lang in voice.languages and "female" in voice.name.lower():
            engine.setProperty('voice', voice.id)
            print(f"Selected voice: {voice.name}")  # Debug print to confirm selected voice
            break
    else:
        # If no female voice is found, set to the first available voice
        engine.setProperty('voice', voices[0].id)
        print(f"Default voice: {voices[0].name}")  # Debug print for fallback

# Utility Functions
def get_response(user_input):
    convo_message = convo.send_message(user_input)
    print(f"[DEBUG] Gemini Response: {convo_message.text}")
    return convo_message.text

def speak(text, lang='en'):
    """Speak the given text using pyttsx3."""
    global stop_flag  # Explicitly reference the global stop_flag
    print(f"Aleo: {text}")  # Debug print
    set_voice(lang)
    try:
        engine.say(text)
        engine.runAndWait()
    except Exception as e:
        print(f"[ERROR] TTS error: {str(e)}")

def play_music(song_name):
    global current_player, music_playing, stop_flag
    try:
        ydl_opts = {'format': 'bestaudio/best', 'noplaylist': True, 'quiet': True}
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(f"ytsearch:{song_name}", download=False)['entries'][0]
            url = info['url']
            title = info['title']
            speak(f"Playing {title} from YouTube.")
            
            if current_player is not None:
                current_player.stop()
            
            current_player = vlc.MediaPlayer(url)
            current_player.play()
            music_playing = True

            duration = info.get('duration', 0)
            elapsed = 0
            while elapsed < duration:
                if stop_flag:
                    current_player.stop()
                    music_playing = False
                    speak("Music stopped.")
                    return
                time.sleep(1)
                elapsed += 1
            current_player.stop()
            music_playing = False
    except Exception as e:
        speak(f"Error playing music: {str(e)}")

def stop_music():
    global current_player, music_playing
    if current_player is not None:
        current_player.stop()
        music_playing = False
        speak("Music stopped.")
    else:
        speak("No music is currently playing.")

def set_alarm(time_str):
    try:
        alarm_time = datetime.strptime(time_str, "%H:%M").time()
        speak(f"Alarm set for {alarm_time.strftime('%H:%M')}.")
        while True:
            if datetime.now().time() >= alarm_time or stop_flag:
                if stop_flag:
                    speak("Alarm stopped.")
                    return
                speak("Time to wake up!")
                break
            time.sleep(1)
    except ValueError:
        speak("Please provide the time in HH:MM format.")

def get_weather(city):
    try:
        city = city.strip().replace(" ", "+")
        url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={weather_api_key}&units=metric"
        response = requests.get(url).json()
        
        if response.get("cod") == 200:
            weather = response["weather"][0]["description"]
            temp = response["main"]["temp"]
            city_name = response["name"]
            speak(f"The weather in {city_name} is {weather} with a temperature of {temp} degrees Celsius.")
        else:
            error_message = response.get("message", "Unknown error")
            speak(f"City not found or error occurred: {error_message}.")
    except Exception as e:
        speak(f"Error fetching weather: {str(e)}")

# Main loop
wake_word = ["elio", "helio", "aleo", "a.leo", "hey elio", "e.li.o"]
exit_commands = ["exit", "stop", "quit", "bye"]
stop_commands = ["aleo stop", "stop aleo"]

def listen_for_wake_word():
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        recognizer.adjust_for_ambient_noise(source)
        print("Listening for wake word...")
        try:
            audio = recognizer.listen(source)
            command = recognizer.recognize_google(audio).lower()
            return command
        except sr.UnknownValueError:
            return ""
        except sr.RequestError:
            speak("Network error.")

def handle_commands():
    global stop_flag  # Explicitly reference global stop_flag
    recognizer = sr.Recognizer()
    with sr.Microphone() as source:
        recognizer.adjust_for_ambient_noise(source)
        while True:
            try:
                print("Listening for command...")
                audio = recognizer.listen(source)
                command = recognizer.recognize_google(audio).lower()
                print(f"User: {command}")

                if any(stop_cmd in command for stop_cmd in stop_commands):
                    stop_flag = True
                    speak("Stopping assistant.")
                    break

                if music_playing:
                    if "stop music" in command or "music stop" in command:
                        stop_music()
                    else:
                        speak("Please wait until the current song finishes.")
                else:
                    if "weather" in command:
                        city = command.replace("weather in", "").strip()
                        get_weather(city)
                    elif command.startswith("play "):
                        song_name = command.replace("play ", "").strip()
                        play_music(song_name)
                    else:
                        response = get_response(command)
                        speak(response)
            except sr.UnknownValueError:
                speak("Sorry, I didn't understand that.")
            except Exception as e:
                speak(f"An error occurred: {str(e)}")

# Auto-start and main loop
if __name__ == "__main__":
    try:
        speak("Starting Aleo...")
        while True:
            if stop_flag:
                print("[DEBUG] Assistant stopped.")
                break
            command = listen_for_wake_word()
            if any(word in command for word in wake_word):
                speak("Yes, how can I assist?")
                handle_commands()
    except Exception as e:
        print(f"[DEBUG] Unexpected Error: {str(e)}")
